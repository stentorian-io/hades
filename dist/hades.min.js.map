{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/objects/Mutation.js","webpack:///./src/objects/EnumEntry.js","webpack:///./src/objects/enums/MutationTypeEnum.js","webpack:///./src/model/Model.js","webpack:///./src/objects/errors/HadesValidationError.js","webpack:///./src/model/Schema.js","webpack:///./src/database/Table.js","webpack:///./src/objects/errors/HadesUnexpectedValueError.js","webpack:///./src/database/Session.js","webpack:///./src/database/Database.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Mutation","options","this","_type","type","_ModelClass","ModelClass","_fieldsOrNull","fields","_modelIdOrNull","modelId","_willApplyToEntireTable","willApplyToEntireTable","EnumEntry","_key","_value","entry","getValue","MutationTypeEnum","Model","session","tableKey","castValuesAgainstDefinition","_getInstanceRowFromStateOrEmpty","applyMutation","INSERT","UPSERT","DELETE","id","UPDATE","state","rows","HadesValidationError","Error","Schema","schemaDefinition","fieldValues","schemaDefinitionBase","GLOBAL_DEFAULT_KEY_NAME_ID","Number","entries","reduce","fieldInstances","fieldName","FieldClass","fieldWhitelist","isFieldSuperfluous","includes","keys","forEach","toString","join","Table","_createStorageForRows","_meta","_createStorageForMeta","_getModelTableName","JSON","parse","stringify","columns","_getNextId","idBlacklist","push","sort","a","b","lastIdIncremental","rowId","assign","updateRow","insertRow","rowIdBlacklistIndex","indexOf","splice","findNextNonBlacklistedId","idBlacklistIndex","length","toLowerCase","HadesUnexpectedValueError","Session","models","mutation","getType","getModelClass","pointerModelTableOrNull","_getPointerForModelTableOrNull","modelIdOrNull","getModelIdOrNull","fieldsOrNull","getFieldsOrNull","getWillApplyToEntireTable","assertSchemaAllowsFieldsForMutation","equals","_applyInsertMutation","_applyUpsertMutation","_applyDeleteMutation","_applyUpdateMutation","tableKeyOrNull","getTableKeyOrNull","pointerTable","truncate","deleteRow","upsertRow","Database","_registerModels","action","_createSession","_forModelsInSessionCreateTablesIfNeeded","_forModelsInSessionApplyReducers","registeredModels","uniqueModels","_createWarningDuplicateModel","addModels","addSession","table","getKey","addTableKey","mergeIntoState","reducer","modelName","console","warn"],"mappings":"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","file":"hades.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// @flow strict\nimport type { Model } from \"../model/Model\";\nimport type { EnumEntry } from \"../objects/EnumEntry\";\n\ntype MutationOptionsType = {|\n    type: EnumEntry,\n    modelId?: number,\n    fields?: TableRowType,\n    ModelClass: Class<Model>,\n    willApplyToEntireTable?: boolean,\n|};\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200919 Initial creation.\n */\nclass Mutation {\n    _type: EnumEntry;\n    _ModelClass: Class<Model>;\n    _modelIdOrNull: number | null;\n    _willApplyToEntireTable: boolean;\n    _fieldsOrNull: TableRowType | null;\n\n    /**\n     * @param {MutationOptionsType} options\n     */\n    constructor(options: MutationOptionsType): void {\n        this._type = options.type;\n        this._ModelClass = options.ModelClass;\n        this._fieldsOrNull = options.fields || null;\n        this._modelIdOrNull = options.modelId || null;\n        this._willApplyToEntireTable = options.willApplyToEntireTable || false;\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    getType(): EnumEntry {\n        return this._type;\n    }\n\n    /**\n     * @returns {Class<Model>}\n     */\n    getModelClass(): Class<Model> {\n        return this._ModelClass;\n    }\n\n    /**\n     * @returns {number|null}\n     */\n    getModelIdOrNull(): number | null {\n        return this._modelIdOrNull;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    getWillApplyToEntireTable(): boolean {\n        return this._willApplyToEntireTable;\n    }\n\n    /**\n     * @returns {FieldsForMutation|null}\n     */\n    getFieldsOrNull(): TableRowType | null {\n        return this._fieldsOrNull;\n    }\n}\n\nexport { Mutation };\n","// @flow strict\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20201007 Initial creation.\n */\nclass EnumEntry {\n    _key: string;\n    _value: string;\n\n    /**\n     * @param {string} key\n     * @param {string} value\n     */\n    constructor(key: string, value: string): void {\n        this._key = key;\n        this._value = value;\n    }\n\n    /**\n     * @returns {string}\n     */\n    getValue(): string {\n        return this._value;\n    }\n\n    /**\n     * @param {EnumEntry} entry\n     *\n     * @returns {boolean}\n     */\n    equals(entry: EnumEntry): boolean {\n        return entry.getValue() === this._value;\n    }\n}\n\nexport { EnumEntry };\n","// @flow strict\nimport { EnumEntry } from \"../EnumEntry\";\n\n/**\n * Mutation type constants.\n */\nconst MUTATION_TYPE_INSERT: string = \"INSERT\";\nconst MUTATION_TYPE_UPDATE: string = \"UPDATE\";\nconst MUTATION_TYPE_UPSERT: string = \"UPSERT\";\nconst MUTATION_TYPE_DELETE: string = \"DELETE\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20201007 Initial creation.\n */\nclass MutationTypeEnum {\n    /**\n     * @returns {EnumEntry}\n     */\n    static INSERT(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_INSERT, MUTATION_TYPE_INSERT);\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    static UPDATE(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_UPDATE, MUTATION_TYPE_UPDATE);\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    static UPSERT(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_UPSERT, MUTATION_TYPE_UPSERT);\n    }\n\n    /**\n     * @returns {EnumEntry}\n     */\n    static DELETE(): EnumEntry {\n        return new EnumEntry(MUTATION_TYPE_DELETE, MUTATION_TYPE_DELETE);\n    }\n}\n\nexport { MutationTypeEnum };\n","// @flow strict\nimport type { Schema } from \"./Schema\";\nimport { Mutation } from \"../objects/Mutation\";\nimport type { Session } from \"../database/Session\";\nimport { MutationTypeEnum } from \"../objects/enums/MutationTypeEnum\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Model {\n    modelId: number;\n    session: Session;\n    tableKey: string;\n    fields: ModelFieldsType;\n    ModelClass: Class<Model>;\n\n    static session: Session;\n    static tableKey: string;\n\n    static fields: () => Schema;\n    static toString: () => string;\n    static reducer: (action: ActionType) => void;\n\n    /**\n     * @param {Class<Model>} ModelClass\n     * @param {number} modelId\n     */\n    constructor(ModelClass: Class<Model>, modelId: number): void {\n        this.modelId = modelId;\n        this.ModelClass = ModelClass;\n        this.session = this.ModelClass.session;\n        this.tableKey = this.ModelClass.tableKey;\n        this.fields = this.ModelClass.fields().castValuesAgainstDefinition(\n            this._getInstanceRowFromStateOrEmpty()\n        );\n    }\n\n    /**\n     * @param {TableRowType} fields\n     */\n    update(fields: TableRowType): void {\n        this.session.applyMutation(\n            new Mutation({\n                fields,\n                modelId: this.fields.id,\n                ModelClass: this.ModelClass,\n                type: MutationTypeEnum.UPDATE(),\n            })\n        );\n    }\n\n    /**\n     */\n    delete(): void {\n        this.session.applyMutation(\n            new Mutation({\n                modelId: this.fields.id,\n                ModelClass: this.ModelClass,\n                type: MutationTypeEnum.DELETE(),\n            })\n        );\n    }\n\n    /**\n     * @param {TableRowType} fields\n     */\n    static create(fields: TableRowType): void {\n        this.session.applyMutation(\n            new Mutation({\n                fields,\n                ModelClass: this,\n                type: MutationTypeEnum.INSERT(),\n            })\n        );\n    }\n\n    /**\n     * @param {TableRowType} fields\n     */\n    static upsert(fields: TableRowType): void {\n        this.session.applyMutation(\n            new Mutation({\n                fields,\n                ModelClass: this,\n                type: MutationTypeEnum.UPSERT(),\n            })\n        );\n    }\n\n    /**\n     */\n    static deleteAll(): void {\n        this.session.applyMutation(\n            new Mutation({\n                ModelClass: this,\n                willApplyToEntireTable: true,\n                type: MutationTypeEnum.DELETE(),\n            })\n        );\n    }\n\n    /**\n     * @param {string} modelId\n     *\n     * @returns {Model}\n     */\n    static withId(modelId: number): Model {\n        return new Model(this, modelId);\n    }\n\n    /**\n     * @returns {string|null}\n     */\n    static getTableKeyOrNull(): string | null {\n        return this.tableKey || null;\n    }\n\n    /**\n     * @param {string} tableKey\n     */\n    static addTableKey(tableKey: string): void {\n        this.tableKey = tableKey;\n    }\n\n    /**\n     * @param {Session} session\n     */\n    static addSession(session: Session): void {\n        this.session = session;\n    }\n\n    /**\n     * @returns {Model|TableRowType}\n     */\n    _getInstanceRowFromStateOrEmpty(): Model | TableRowType {\n        return this.session.state[this.tableKey].rows[this.modelId] || {};\n    }\n}\n\nexport { Model };\n","// @flow strict\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 22072020 Clean up.\n */\nclass HadesValidationError extends Error {\n    /**\n     * @returns {string}\n     */\n    get name(): string {\n        return \"HadesValidationError\";\n    }\n\n    /**\n     * @param {string} value\n     */\n    set name(value: string): void {\n        // Do nothing.\n    }\n}\n\nexport { HadesValidationError };\n","// @flow strict\n/* global GLOBAL_DEFAULT_KEY_NAME_ID */\nimport type { Model } from \"./Model\";\nimport { HadesValidationError } from \"../objects/errors/HadesValidationError\";\n\n/* eslint-disable flowtype/no-weak-types */\nopaque type SchemaDefinitionType = {|\n    /* eslint-disable-next-line flowtype/no-primitive-constructor-types */\n    [fieldName: string]: Number | Class<any>,\n|};\n\nopaque type FieldInstancesType = [string, Class<any>];\n/* eslint-enable flowtype/no-weak-types */\n\n/**\n * Type constants.\n */\nconst TYPE_UNDEFINED: string = \"undefined\";\n\n/**\n * Separator constants.\n */\nconst SEPARATOR_SPACE: string = \" \";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200722 Initial creation.\n */\nclass Schema {\n    schemaDefinition: SchemaDefinitionType;\n\n    /**\n     * @param {SchemaDefinitionType} schemaDefinition\n     */\n    constructor(schemaDefinition: SchemaDefinitionType): void {\n        this.schemaDefinition = schemaDefinition;\n    }\n\n    /**\n     * @param {TableRowType} fieldValues\n     *\n     * @returns {ModelFieldsType}\n     * @throws {HadesValidationError}\n     */\n    castValuesAgainstDefinition(fieldValues: TableRowType): ModelFieldsType {\n        if (fieldValues[GLOBAL_DEFAULT_KEY_NAME_ID]) {\n            // ID field is set.\n        } else {\n            throw new HadesValidationError(\n                \"ID is a required field for Model schema definition.\"\n            );\n        }\n\n        /**\n         * @param {SchemaDefinitionType} fieldInstances\n         * @param {FieldInstancesType} currentField\n         *\n         * @returns {SchemaDefinitionType}\n         */\n        function reduceSchemaDefinition(\n            fieldInstances: SchemaDefinitionType,\n            [fieldName, FieldClass]: FieldInstancesType\n        ): SchemaDefinitionType {\n            return {\n                ...fieldInstances,\n                [fieldName]: new FieldClass(fieldValues[fieldName]),\n            };\n        }\n\n        const schemaDefinitionBase: SchemaDefinitionType = {\n            // ID is omitted from schema definition â€” it's always included.\n            [GLOBAL_DEFAULT_KEY_NAME_ID]: Number(\n                fieldValues[GLOBAL_DEFAULT_KEY_NAME_ID]\n            ),\n        };\n\n        // $FlowIssue\n        return Object.entries(this.schemaDefinition).reduce(\n            reduceSchemaDefinition,\n            schemaDefinitionBase\n        );\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     * @param {TableRowType} fields\n     *\n     * @throws {HadesValidationError}\n     */\n    assertSchemaAllowsFieldsForMutation(\n        ModelClass: Class<Model>,\n        fields: TableRowType\n    ): void {\n        const fieldWhitelist: Array<string> = [GLOBAL_DEFAULT_KEY_NAME_ID];\n\n        /**\n         * @param {string} key\n         *\n         * @returns {boolean}\n         *\n         * @this Schema\n         */\n        function isFieldSuperfluous(key: string): boolean {\n            return (\n                fieldWhitelist.includes(key) === false &&\n                typeof this.schemaDefinition[key] === TYPE_UNDEFINED\n            );\n        }\n\n        Object.keys(fields).forEach((key: string): void => {\n            if (isFieldSuperfluous.call(this, key)) {\n                throw new HadesValidationError(\n                    [\n                        `Cannot apply mutation to ${ModelClass.toString()} model,`,\n                        `found superfluous property '${key}'.`,\n                    ].join(SEPARATOR_SPACE)\n                );\n            } else {\n                // Field is allowed.\n            }\n        });\n    }\n}\n\nexport { Schema };\n","// @flow strict\n/* global GLOBAL_DEFAULT_KEY_NAME_ID */\nimport type { Model } from \"../model/Model\";\nimport { HadesValidationError } from \"../objects/errors/HadesValidationError\";\n\nopaque type RowStorageType = { ... };\n\nopaque type MetaStorageType = {|\n    lastIdIncremental: number,\n    idBlacklist: Array<number>,\n|};\n\n/**\n * Table constants.\n */\nconst TABLE_NAME_PREFIX: string = \"table_\";\n\n/**\n * Index constants.\n */\nconst INDEX_INVALID: number = -1;\n\n/**\n * Counter constants.\n */\nconst INCREMENT_STEP: number = 1;\nconst INCREMENT_START: number = 0;\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Table {\n    rows: RowStorageType;\n\n    _key: string;\n    _meta: MetaStorageType;\n\n    /**\n     * @param {Class<Model>} ModelClass\n     */\n    constructor(ModelClass: Class<Model>): void {\n        this.rows = this._createStorageForRows();\n\n        this._meta = this._createStorageForMeta();\n        this._key = this._getModelTableName(ModelClass);\n    }\n\n    /**\n     * @returns {string}\n     */\n    getKey(): string {\n        return this._key;\n    }\n\n    /**\n     * @returns {RowStorageType}\n     */\n    getRows(): RowStorageType {\n        return JSON.parse(JSON.stringify(this.rows));\n    }\n\n    /**\n     * @param {TableRowType} columns\n     */\n    insertRow(columns: TableRowType): void {\n        /**\n         * @returns {number}\n         *\n         * @this Table\n         */\n        function determineModelId(): number {\n            if (columns[GLOBAL_DEFAULT_KEY_NAME_ID]) {\n                return columns[GLOBAL_DEFAULT_KEY_NAME_ID];\n            } else {\n                return this._getNextId();\n            }\n        }\n\n        const modelId: number = determineModelId.call(this);\n\n        if (this.rows[modelId]) {\n            throw new HadesValidationError(\n                `Cannot insert new row since given ID '${modelId}' is not unique.`\n            );\n        } else {\n            this.rows[modelId] = {\n                ...columns,\n                [GLOBAL_DEFAULT_KEY_NAME_ID]: modelId,\n            };\n\n            if (columns[GLOBAL_DEFAULT_KEY_NAME_ID]) {\n                this._meta.idBlacklist.push(modelId);\n                this._meta.idBlacklist.sort(\n                    (a: number, b: number): number => a - b\n                );\n            } else {\n                this._meta.lastIdIncremental = modelId;\n            }\n        }\n    }\n\n    /**\n     * @param {number} rowId\n     * @param {TableRowType} columns\n     */\n    updateRow(rowId: number, columns: TableRowType): void {\n        Object.assign(this.rows[rowId], columns);\n    }\n\n    /**\n     * @param {TableRowType} columns\n     */\n    upsertRow(columns: TableRowType): void {\n        if (\n            columns[GLOBAL_DEFAULT_KEY_NAME_ID] &&\n            this.rows[columns[GLOBAL_DEFAULT_KEY_NAME_ID]]\n        ) {\n            this.updateRow(columns[GLOBAL_DEFAULT_KEY_NAME_ID], columns);\n        } else {\n            this.insertRow(columns);\n        }\n    }\n\n    /**\n     * @param {number} rowId\n     */\n    deleteRow(rowId: number): void {\n        const { idBlacklist }: MetaStorageType = this._meta;\n        const rowIdBlacklistIndex: number = idBlacklist.indexOf(rowId);\n\n        if (rowIdBlacklistIndex === INDEX_INVALID) {\n            // No need to clear this ID from the blacklist.\n        } else {\n            idBlacklist.splice(rowIdBlacklistIndex, 1);\n        }\n\n        delete this.rows[rowId.toString()];\n    }\n\n    /**\n     */\n    truncate(): void {\n        this.rows = this._createStorageForRows();\n        this._meta = this._createStorageForMeta();\n    }\n\n    /**\n     * @returns {RowStorageType}\n     */\n    _createStorageForRows(): RowStorageType {\n        return {};\n    }\n\n    /**\n     * @returns {MetaStorageType}\n     */\n    _createStorageForMeta(): MetaStorageType {\n        return {\n            idBlacklist: [],\n            lastIdIncremental: INCREMENT_START,\n        };\n    }\n\n    /**\n     * @returns {number}\n     */\n    _getNextId(): number {\n        const { idBlacklist, lastIdIncremental }: MetaStorageType = this._meta;\n        const nextIdIncremental: number = lastIdIncremental + INCREMENT_STEP;\n\n        /**\n         * @param {number} id\n         *\n         * @returns {number}\n         */\n        function findNextNonBlacklistedId(id: number): number {\n            const idBlacklistIndex: number = idBlacklist.indexOf(id);\n\n            if (idBlacklistIndex === INDEX_INVALID) {\n                return id;\n            } else if (idBlacklistIndex === idBlacklist.length - 1) {\n                return id + INCREMENT_STEP;\n            } else {\n                return findNextNonBlacklistedId(id + INCREMENT_STEP);\n            }\n        }\n\n        return findNextNonBlacklistedId(nextIdIncremental);\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     *\n     * @returns {string}\n     */\n    _getModelTableName(ModelClass: Class<Model>): string {\n        return `${TABLE_NAME_PREFIX}${ModelClass.toString().toLowerCase()}`;\n    }\n}\n\nexport { Table };\n","// @flow strict\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 22072020 Clean up.\n */\nclass HadesUnexpectedValueError extends Error {\n    /**\n     * @returns {string}\n     */\n    get name(): string {\n        return \"HadesUnexpectedValueError\";\n    }\n\n    /**\n     * @param {string} value\n     */\n    set name(value: string): void {\n        // Do nothing.\n    }\n}\n\nexport { HadesUnexpectedValueError };\n","// @flow strict\nimport type { Table } from \"./Table\";\nimport type { Model } from \"../model/Model\";\nimport type { Mutation } from \"../objects/Mutation\";\nimport type { EnumEntry } from \"../objects/EnumEntry\";\nimport { MutationTypeEnum } from \"../objects/enums/MutationTypeEnum\";\nimport { HadesUnexpectedValueError } from \"../objects/errors/HadesUnexpectedValueError\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Session {\n    state: StateType;\n    models: Array<Class<Model>>;\n\n    /**\n     * @param {StateType} state\n     */\n    constructor(state: StateType): void {\n        this.state = state;\n    }\n\n    /**\n     * @param {Array<Class<Model>>} models\n     */\n    addModels(models: Array<Class<Model>>): void {\n        this.models = models;\n    }\n\n    /**\n     * @param {StateType} object\n     */\n    mergeIntoState(object: StateType): void {\n        Object.assign(this.state, object);\n    }\n\n    /**\n     * @param {Mutation} mutation\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    applyMutation(mutation: Mutation): void {\n        const type: EnumEntry = mutation.getType();\n        const ModelClass: Class<Model> = mutation.getModelClass();\n        const pointerModelTableOrNull: Table | null = this._getPointerForModelTableOrNull(\n            ModelClass\n        );\n\n        if (pointerModelTableOrNull) {\n            // Found pointer to model's table.\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Cannot apply mutation to Model without table pointer.\"\n            );\n        }\n\n        const modelIdOrNull: number | null = mutation.getModelIdOrNull();\n        const fieldsOrNull: TableRowType | null = mutation.getFieldsOrNull();\n        const willApplyToEntireTable: boolean = mutation.getWillApplyToEntireTable();\n\n        if (fieldsOrNull) {\n            ModelClass.fields().assertSchemaAllowsFieldsForMutation(\n                ModelClass,\n                fieldsOrNull\n            );\n        } else {\n            // No fields for this mutation type.\n        }\n\n        if (type.equals(MutationTypeEnum.INSERT())) {\n            this._applyInsertMutation(pointerModelTableOrNull, fieldsOrNull);\n        } else if (type.equals(MutationTypeEnum.UPSERT())) {\n            this._applyUpsertMutation(pointerModelTableOrNull, fieldsOrNull);\n        } else if (type.equals(MutationTypeEnum.DELETE())) {\n            this._applyDeleteMutation(\n                pointerModelTableOrNull,\n                modelIdOrNull,\n                willApplyToEntireTable\n            );\n        } else if (type.equals(MutationTypeEnum.UPDATE())) {\n            this._applyUpdateMutation(\n                pointerModelTableOrNull,\n                fieldsOrNull,\n                modelIdOrNull\n            );\n        } else {\n            throw new HadesUnexpectedValueError(\n                `Unexpected mutation type '${type.getValue()}'.`\n            );\n        }\n    }\n\n    /**\n     * @param {Class<Model>} ModelClass\n     *\n     * @returns {Table|null}\n     */\n    _getPointerForModelTableOrNull(ModelClass: Class<Model>): Table | null {\n        const tableKeyOrNull: string | null = ModelClass.getTableKeyOrNull();\n\n        if (tableKeyOrNull) {\n            return this.state[tableKeyOrNull];\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {number|null} modelIdOrNull\n     * @param {boolean} willApplyToEntireTable\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyDeleteMutation(\n        pointerTable: Table,\n        modelIdOrNull: number | null,\n        willApplyToEntireTable: boolean\n    ): void {\n        if (willApplyToEntireTable) {\n            pointerTable.truncate();\n        } else if (modelIdOrNull) {\n            pointerTable.deleteRow(modelIdOrNull);\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Model ID cannot be null for DELETE MutationType.\"\n            );\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {TableRowType|null} fieldsOrNull\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyInsertMutation(\n        pointerTable: Table,\n        fieldsOrNull: TableRowType | null\n    ): void {\n        if (fieldsOrNull) {\n            pointerTable.insertRow(fieldsOrNull);\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Fields are required for INSERT MutationType.\"\n            );\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {TableRowType|null} fieldsOrNull\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyUpsertMutation(\n        pointerTable: Table,\n        fieldsOrNull: TableRowType | null\n    ): void {\n        if (fieldsOrNull) {\n            pointerTable.upsertRow(fieldsOrNull);\n        } else {\n            throw new HadesUnexpectedValueError(\n                \"Fields are required for UPSERT MutationType.\"\n            );\n        }\n    }\n\n    /**\n     * @param {Table} pointerTable\n     * @param {TableRowType|null} fieldsOrNull\n     * @param {number|null} modelIdOrNull\n     *\n     * @throws {HadesUnexpectedValueError}\n     */\n    _applyUpdateMutation(\n        pointerTable: Table,\n        fieldsOrNull: TableRowType | null,\n        modelIdOrNull: number | null\n    ): void {\n        if (fieldsOrNull === null) {\n            throw new HadesUnexpectedValueError(\n                \"Fields are required for UPDATE MutationType.\"\n            );\n        } else if (modelIdOrNull === null) {\n            throw new HadesUnexpectedValueError(\n                \"Model ID cannot be null for UPDATE MutationType.\"\n            );\n        } else {\n            pointerTable.updateRow(modelIdOrNull, fieldsOrNull);\n        }\n    }\n}\n\nexport { Session };\n","// @flow strict\nimport { Table } from \"./Table\";\nimport { Session } from \"./Session\";\nimport type { Model } from \"../model/Model\";\n\n/**\n * Type constants.\n */\nconst TYPE_FUNCTION: string = \"function\";\n\n/**\n * @author Daniel van Dijk <daniel@invidiacreative.net>\n * @since 20200718 Initial creation.\n */\nclass Database {\n    registeredModels: Array<Class<Model>>;\n\n    /**\n     * @param {Array<Class<Model>>} models\n     */\n    constructor(...models: Array<Class<Model>>): void {\n        this._registerModels(models);\n    }\n\n    /**\n     * @returns {Function}\n     */\n    reducer(): (state: StateType, action: ActionType) => StateType {\n        /**\n         * @param {StateType} [state]\n         * @param {ActionType} action\n         *\n         * @returns {StateType}\n         */\n        return (state: StateType = {}, action: ActionType): StateType => {\n            const session: Session = this._createSession(state);\n\n            this._forModelsInSessionCreateTablesIfNeeded(session);\n            this._forModelsInSessionApplyReducers(session, action);\n\n            return session.state;\n        };\n    }\n\n    /**\n     * @param {Array<Class<Model>>} models\n     */\n    _registerModels(models: Array<Class<Model>>): void {\n        /**\n         * @param {Array<Class<Model>>} uniqueModels\n         * @param {Class<Model>} ModelClass\n         *\n         * @this Database\n         *\n         * @returns {Array<Class<Model>>}\n         */\n        function uniqueModelReducer(\n            uniqueModels: Array<Class<Model>>,\n            ModelClass: Class<Model>\n        ): Array<Class<Model>> {\n            if (uniqueModels.includes(ModelClass)) {\n                this._createWarningDuplicateModel(ModelClass.toString());\n            } else {\n                uniqueModels.push(ModelClass);\n            }\n\n            return uniqueModels;\n        }\n\n        this.registeredModels = models.reduce(\n            uniqueModelReducer.bind(this),\n            []\n        );\n    }\n\n    /**\n     * @param {StateType} state\n     *\n     * @returns {Session}\n     */\n    _createSession(state: StateType): Session {\n        const session: Session = new Session(state);\n\n        session.addModels(this.registeredModels);\n        this.registeredModels.forEach((ModelClass: Class<Model>): void => {\n            ModelClass.addSession(session);\n        });\n\n        return session;\n    }\n\n    /**\n     * @param {Session} session\n     */\n    _forModelsInSessionCreateTablesIfNeeded(session: Session): void {\n        session.models.forEach((ModelClass: Class<Model>): void => {\n            const tableKeyOrNull:\n                | string\n                | null = ModelClass.getTableKeyOrNull();\n\n            if (tableKeyOrNull && session.state[tableKeyOrNull]) {\n                // Table already exists.\n            } else {\n                const table: Table = new Table(ModelClass);\n                const tableKey: string = table.getKey();\n\n                ModelClass.addTableKey(tableKey);\n                session.mergeIntoState({ [tableKey]: table });\n            }\n        });\n    }\n\n    /**\n     * @param {Session} session\n     * @param {ActionType} action\n     */\n    _forModelsInSessionApplyReducers(\n        session: Session,\n        action: ActionType\n    ): void {\n        session.models.forEach((ModelClass: Class<Model>): void => {\n            if (typeof ModelClass.reducer === TYPE_FUNCTION) {\n                ModelClass.reducer(action);\n            } else {\n                // No reducer defined for this model.\n            }\n        });\n    }\n\n    /**\n     * @param {string} modelName\n     */\n    _createWarningDuplicateModel(modelName: string): void {\n        console.warn(`Tried to register duplicate Model: '${modelName}'.`);\n    }\n}\n\nexport { Database };\n"],"sourceRoot":""}